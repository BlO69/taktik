<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Accueil — taktik</title>
  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Font Awesome CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha512-..." crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    :root{ --cell-size:48px; }
    html,body{height:100%;}
    body{overflow-x:hidden; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale}

    .glass {
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid rgba(0,0,0,0.06);
      backdrop-filter: blur(6px);
    }
    .focus-ring:focus { outline: none; box-shadow: 0 0 0 4px rgba(99,102,241,0.12); border-color: rgb(99,102,241); }

    .ttt-cell { aspect-ratio: 1/1; display:flex;align-items:center;justify-content:center;font-size:1.15rem;font-weight:700;cursor:pointer; }

    .board-cell { width:var(--cell-size); height:var(--cell-size); display:flex; align-items:center; justify-content:center; border:1px solid rgba(0,0,0,0.06); background:transparent; box-sizing:border-box; }
    .board-viewport { overflow:auto; border-radius:8px; }
    .piece-img { width:calc(var(--cell-size) * 0.75); height:calc(var(--cell-size) * 0.75); object-fit:contain; }

    .minimap { width:100%; height:96px; overflow:hidden; background:#0f1724; border-radius:6px; display:flex; align-items:center; justify-content:center; }

    .hambtn { display:inline-flex; align-items:center; justify-content:center; width:44px; height:44px; border-radius:8px; }
    @media (min-width: 768px) { .mobile-only { display:none !important; } }

    /* prevent main grid from causing horizontal overflow on small screens */
    .no-overflow { max-width:100%; }
  </style>
</head>
<body class="min-h-screen bg-gray-50 text-slate-800 antialiased">
  <div class="max-w-5xl mx-auto px-4 py-8 no-overflow">
    <header class="flex items-center justify-between mb-6">
      <div class="flex items-center gap-4">
        <img src="logo.png" alt="taktik" class="w-12 h-12 rounded-lg bg-white/5 p-2 object-contain" />
        <div>
          <h1 class="text-2xl font-extrabold text-sky-600">taktik</h1>
          <p class="text-sm text-slate-500">Bienvenue sur la plateforme</p>
        </div>
      </div>

      <div class="flex items-center gap-3">
        <button id="hamburger" aria-label="Ouvrir le menu" class="hambtn mobile-only glass p-1">
          <i class="fa-solid fa-bars text-slate-700"></i>
        </button>

        <div id="userPreview" class="hidden md:flex items-center gap-3">
          <img id="navAvatar" src="logo.png" alt="avatar" class="w-10 h-10 rounded-full object-cover border border-slate-200" />
          <div class="text-right">
            <div id="navName" class="text-sm font-medium">Invité</div>
            <div id="navEmail" class="text-xs text-slate-500">—</div>
          </div>
        </div>

        <button id="logoutBtn" class="px-3 py-2 rounded-md bg-sky-50 hover:bg-sky-100 text-sm hidden">Se déconnecter</button>
      </div>
    </header>

    <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
      <!-- NAV -->
      <nav
  id="mainNav"
  class="fixed inset-0 z-50 md:z-auto md:static md:col-span-1
         glass p-4 rounded-xl
         hidden md:block">
        <ul class="space-y-2">
          <li>
            <button class="w-full flex items-center gap-3 px-3 py-2 rounded-md bg-sky-500 text-white font-semibold" id="menuHome">
              <i class="fa-solid fa-house"></i><span>Accueil</span>
            </button>
          </li>
          <li>
            <button class="w-full flex items-center gap-3 px-3 py-2 rounded-md hover:bg-slate-100" id="menuStats">
              <i class="fa-solid fa-chart-line"></i><span>Statistiques</span>
            </button>
          </li>
          <li>
            <button class="w-full flex items-center gap-3 px-3 py-2 rounded-md hover:bg-slate-100" id="menuGames">
              <i class="fa-solid fa-gamepad"></i><span>Jeux en cours</span>
            </button>
          </li>
<li>
  <button class="w-full relative flex items-center gap-3 px-3 py-2 rounded-md hover:bg-slate-100" id="menuNotifications" aria-haspopup="true" aria-expanded="false">
    <i class="fa-solid fa-bell"></i>
    <span>Notifications</span>
    <!-- badge -->
    <span id="notifBadge" class="absolute right-3 top-1/2 -translate-y-1/2 inline-flex items-center justify-center px-2 py-0.5 text-xs font-semibold leading-none rounded-full bg-red-600 text-white hidden">0</span>
  </button>
</li>

          <li>
            <button class="w-full flex items-center gap-3 px-3 py-2 rounded-md hover:bg-slate-100" id="menuTiks">
              <i class="fa-solid fa-coins"></i><span>Tiks</span>
            </button>
          </li>
          <li>
            <button class="w-full flex items-center gap-3 px-3 py-2 rounded-md hover:bg-slate-100" id="menuTx">
              <i class="fa-solid fa-exchange-alt"></i><span>Transactions</span>
            </button>
          </li>
          <li>
            <button class="w-full flex items-center gap-3 px-3 py-2 rounded-md hover:bg-slate-100" id="menuMingots">
              <i class="fa-solid fa-gem"></i><span>Mingots</span>
            </button>
          </li>
          <li>
            <button class="w-full flex items-center gap-3 px-3 py-2 rounded-md hover:bg-slate-100" id="menuProfile">
              <i class="fa-solid fa-user"></i><span>Mon profil</span>
            </button>
          </li>
        </ul>
      </nav>

      <!-- MAIN -->
      <main class="md:col-span-3 space-y-6">
        <!-- Welcome / Quick actions -->
        <section id="homePanel" class="glass p-6 rounded-xl">
          <div class="flex items-center justify-between">
            <div>
              <h2 class="text-xl font-bold text-slate-800">Bienvenue sur taktik</h2>
              <p class="text-slate-600 mt-1">Prêt à jouer ? Rejoins une partie ou commence une nouvelle.</p>
            </div>

            <div class="flex items-center gap-3">
              <button id="newGameBtn" class="px-4 py-2 rounded-md bg-sky-500 text-white font-semibold">Nouvelle partie</button>
              <button id="profileBtn" class="px-3 py-2 rounded-md bg-white/50 hover:bg-white/60">Mon profil</button>
            </div>
          </div>

          <!-- Gomoku / 20x20 board (viewport 9x8) -->
          <div class="mt-6 grid gap-6 md:grid-cols-2">
            <div class="bg-white p-4 rounded-lg overflow-hidden">
              <div class="flex items-center justify-between mb-3">
                <h3 class="font-semibold text-slate-800">Jeu — Aligner 5</h3>
                <div class="flex items-center gap-2">
                  <button id="modeToggle" class="px-3 py-1 rounded-md bg-slate-100 text-sm">Mode: IA basique</button>
                  <button id="duoToggle" class="px-3 py-1 rounded-md bg-slate-100 text-sm">Duo Local</button>
                </div>
              </div>

              <div class="flex gap-4 flex-col md:flex-row">
                <div class="flex-1">
                  <div class="board-viewport border rounded-md" id="boardViewport" style="max-width:100%;">
                    <div id="boardGrid" class="grid" style="grid-template-columns: repeat(20, var(--cell-size));"></div>
                  </div>

                  <div class="mt-3 flex items-center justify-between text-sm">
                    <div>Tour: <strong id="currentTurn">X</strong></div>
                    <div>Manches — X: <strong id="scoreX">0</strong> | O: <strong id="scoreO">0</strong></div>
                    <div>Séries — X: <strong id="seriesX">0</strong> | O: <strong id="seriesO">0</strong></div>
                  </div>

                  <div class="mt-3 flex gap-2">
                    <button id="resetManche" class="px-3 py-1 rounded-md bg-slate-100">Reset manche</button>
                    <button id="resetSerie" class="px-3 py-1 rounded-md bg-slate-100">Reset série</button>
                  </div>
                </div>

                <div class="w-full md:w-40">
                  <div class="p-3 bg-slate-50 border rounded-md text-center">
                    <div class="text-xs text-slate-500">Légende</div>
<div class="mt-2 flex flex-col items-center gap-2">
  <div class="flex items-center gap-2">
    <img src="./pion_x.svg" alt="Pion X" class="w-10 h-10 object-contain rounded-md" />
    <img src="./pion_o.svg" alt="Pion O" class="w-10 h-10 object-contain rounded-md" />
  </div>
</div>
                  </div>

                  <div class="mt-3 minimap" id="minimap" title="Cliquez pour centrer la vue">Mini-map</div>
                </div>
              </div>

            </div>

            <!-- Stats / Placeholder -->
            <div class="bg-white p-4 rounded-lg">
              <h3 class="font-semibold text-slate-800 mb-3">Statistiques rapides</h3>
              <ul class="text-slate-700 space-y-2">
                <li><strong id="statGames">0</strong> parties jouées</li>
                <li><strong id="statWins">0</strong> victoires</li>
                <li><strong id="statTiks">0</strong> Tiks</li>
              </ul>
            </div>
          </div>
        </section>

        <!-- Profile editor (moved to panel toggled via menuProfile / profileBtn) -->
        <section id="profilePanel" class="glass p-6 rounded-xl hidden">
          <h3 class="text-lg font-bold text-slate-800 mb-3">Mettre à jour le profil</h3>

          <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div class="col-span-1 flex flex-col items-center gap-3">
              <div class="w-36 h-36 rounded-full overflow-hidden bg-slate-100 border">
                <img id="avatarPreview" src="logo.png" alt="avatar" class="w-full h-full object-cover" />
              </div>
              <input id="avatarFile" type="file" accept="image/*" class="text-sm text-slate-600" />
              <div class="text-xs text-slate-500">Formats: PNG, JPG. Max recommandé: 2MB</div>
            </div>

            <div class="col-span-2 space-y-3">
              <label class="block">
                <span class="text-sm text-slate-700">Pseudo</span>
                <input id="usernameInput" type="text" placeholder="Ton pseudo" class="mt-1 block w-full px-3 py-2 bg-white rounded-md border border-slate-200 focus-ring" />
              </label>

              <div class="flex gap-3">
                <button id="saveProfile" class="px-4 py-2 bg-sky-500 rounded-md text-white font-semibold">Enregistrer</button>
                <button id="cancelProfile" class="px-4 py-2 bg-white/50 rounded-md">Annuler</button>
              </div>

              <div id="profileMsg" class="text-sm text-slate-600"></div>
            </div>
          </div>
        </section>

        <!-- Other panels (placeholders toggled by menu) -->
        <section id="placeholderPanel" class="glass p-6 rounded-xl hidden">
          <h3 class="text-lg font-semibold text-slate-800" id="placeholderTitle">Titre</h3>
          <p class="text-slate-600 mt-2" id="placeholderText">Contenu à venir...</p>
        </section>
      </main>
    </div>
  </div>

  <!-- Core page scripts -->
  <script type="module">
    // Try to import supabase client; if missing, continue in offline/demo mode
    let supabase = null;
    try {
      const mod = await import('./supabaseClient.js');
      supabase = mod.supabase;
    } catch (e) {
      console.warn('supabaseClient.js non trouvé — mode demo', e);
    }

    // Basic auth fill (non-blocking)
    async function ensureAuth() {
      if (!supabase) return;
      try {
        const res = await supabase.auth.getSession();
        const session = res?.data?.session ?? null;
        if (!session || !session.user) return;
        const user = session.user;
        document.getElementById('navEmail').textContent = user.email || '';
        const metadata = user.user_metadata ?? user?.app_metadata ?? {};
        document.getElementById('navName').textContent = metadata.username || metadata.name || user.email.split('@')[0] || 'Utilisateur';
        if (metadata.avatar_url) {
          document.getElementById('navAvatar').src = metadata.avatar_url;
          document.getElementById('avatarPreview').src = metadata.avatar_url;
        }
        document.getElementById('logoutBtn').classList.remove('hidden');
      } catch (e) { console.warn('Erreur récupération session', e); }
    }
    ensureAuth();
// after ensureAuth() finishes populating user UI:
if (window.initNotifications) window.initNotifications();
    // ------------------------------------------------------------------
    // Logout button — déconnexion de la session Supabase (ou fallback)
    // ------------------------------------------------------------------
    (function(){
      const logoutBtn = document.getElementById('logoutBtn');
      if (!logoutBtn) return;

      logoutBtn.addEventListener('click', async (ev) => {
        ev.preventDefault();
        // utilise le client supabase local si présent, sinon fallback sur window.supabase
        const client = (typeof supabase !== 'undefined' && supabase) ? supabase : (window.supabase ?? null);

        // Si pas de client, effectuer un fallback (vider le state local et recharger)
        if (!client || !client.auth || typeof client.auth.signOut !== 'function') {
          console.warn('Client supabase non disponible — déconnexion fallback');
          try { localStorage.clear(); sessionStorage.clear(); } catch (_) {}
          location.reload();
          return;
        }

        try {
          const { error } = await client.auth.signOut();
          if (error) {
            console.error('Erreur lors de la déconnexion', error);
            alert('Erreur lors de la déconnexion — voir console');
            return;
          }

          // UI updates après déconnexion
          document.getElementById('navName').textContent = 'Invité';
          document.getElementById('navEmail').textContent = '—';
          document.getElementById('navAvatar').src = 'logo.png';
          logoutBtn.classList.add('hidden');

          // optionnel : rediriger vers la page d'accueil / login
          // location.href = 'index.html';
          // ou juste recharger pour que les listeners auth gèrent l'affichage
          location.reload();
        } catch (err) {
          console.error('Exception lors de signOut():', err);
          alert('Impossible de se déconnecter — voir console.');
        }
      });
    })();

    // menu & hamburger toggle
    const hamburger = document.getElementById('hamburger');
    const mainNav = document.getElementById('mainNav');
    hamburger.addEventListener('click', () => {
      mainNav.classList.toggle('hidden');
    });

    // menu wiring
    const menuHome = document.getElementById('menuHome');
    const menuStats = document.getElementById('menuStats');
    const menuGames = document.getElementById('menuGames');
    const menuTiks = document.getElementById('menuTiks');
    const menuTx = document.getElementById('menuTx');
    const menuMingots = document.getElementById('menuMingots');
    const menuProfile = document.getElementById('menuProfile');
const menuNotifications = document.getElementById('menuNotifications');

    const homePanel = document.getElementById('homePanel');
    const profilePanel = document.getElementById('profilePanel');
    const placeholderPanel = document.getElementById('placeholderPanel');

    function setActiveMenu(btn) {
      [menuHome, menuStats, menuGames, menuNotifications, menuTiks, menuTx, menuMingots, menuProfile].forEach(el => el.classList.remove('bg-sky-500','text-white','font-semibold'));
      btn.classList.add('bg-sky-500','text-white','font-semibold');
    }

    menuHome.addEventListener('click', () => { setActiveMenu(menuHome); homePanel.classList.remove('hidden'); profilePanel.classList.add('hidden'); placeholderPanel.classList.add('hidden'); if(window.innerWidth<768) mainNav.classList.add('hidden'); });
    menuStats.addEventListener('click', () => { setActiveMenu(menuStats); homePanel.classList.add('hidden'); profilePanel.classList.add('hidden'); placeholderPanel.classList.remove('hidden'); document.getElementById('placeholderTitle').textContent='Statistiques'; document.getElementById('placeholderText').textContent='Ici s’afficheront tes statistiques détaillées.'; if(window.innerWidth<768) mainNav.classList.add('hidden'); });
    // Avant: (remplacement complet du handler menuGames)
menuGames.addEventListener('click', async () => {
  setActiveMenu(menuGames);
  homePanel.classList.add('hidden');
  profilePanel.classList.add('hidden');
  placeholderPanel.classList.remove('hidden');
  document.getElementById('placeholderTitle').textContent = 'Jeux en cours';
  document.getElementById('placeholderText').textContent = 'Chargement...';
  if (window.innerWidth < 768) mainNav.classList.add('hidden');

  // Lazy-load create_game.js et l'initialiser avec le client supabase si disponible
  try {
    // si l'API est déjà initialisée, on l'utilise
    if (window.taktikCreateGame && typeof window.taktikCreateGame.searchProfiles === 'function') {
      // create_game a déjà rendu son UI dans placeholderPanel
      document.getElementById('placeholderText').textContent = '';
      return;
    }

    const mod = await import('./create_game.js');
    if (mod && typeof mod.default === 'function') {
      // mod.default initialise create_game (il attend facultativement le client supabase)
      await mod.default(supabase);
      // create_game.js remplace placeholderText avec son UI (voir create_game.js)
      document.getElementById('placeholderText').textContent = '';
    } else {
      document.getElementById('placeholderText').textContent = 'Matchmaking non disponible.';
    }
  } catch (e) {
    console.warn('Erreur chargement create_game.js', e);
    document.getElementById('placeholderText').textContent = 'Matchmaking non disponible.';
  }
});
    menuTiks.addEventListener('click', () => { setActiveMenu(menuTiks); homePanel.classList.add('hidden'); profilePanel.classList.add('hidden'); placeholderPanel.classList.remove('hidden'); document.getElementById('placeholderTitle').textContent='Tiks'; document.getElementById('placeholderText').textContent='Solde, historique et options d’achat de Tiks.'; if(window.innerWidth<768) mainNav.classList.add('hidden'); });
    menuTx.addEventListener('click', () => { setActiveMenu(menuTx); homePanel.classList.add('hidden'); profilePanel.classList.add('hidden'); placeholderPanel.classList.remove('hidden'); document.getElementById('placeholderTitle').textContent='Transactions'; document.getElementById('placeholderText').textContent='Historique de transactions.'; if(window.innerWidth<768) mainNav.classList.add('hidden'); });
    // fixed: mingots must show Mingots content, not profile
    menuMingots.addEventListener('click', () => { setActiveMenu(menuMingots); homePanel.classList.add('hidden'); profilePanel.classList.add('hidden'); placeholderPanel.classList.remove('hidden'); document.getElementById('placeholderTitle').textContent='Mingots'; document.getElementById('placeholderText').textContent='Tes mingots : collection, mise en vente et historique.'; if(window.innerWidth<768) mainNav.classList.add('hidden'); });
    menuProfile.addEventListener('click', () => { setActiveMenu(menuProfile); homePanel.classList.add('hidden'); profilePanel.classList.remove('hidden'); placeholderPanel.classList.add('hidden'); if(window.innerWidth<768) mainNav.classList.add('hidden'); });
    menuNotifications.addEventListener('click', async () => {
  setActiveMenu(menuNotifications);
  // afficher panel notifications
  homePanel.classList.add('hidden');
  profilePanel.classList.add('hidden');
  placeholderPanel.classList.remove('hidden');
  document.getElementById('placeholderTitle').textContent = 'Notifications';
  document.getElementById('placeholderText').textContent = 'Chargement des notifications...';
  if(window.innerWidth<768) mainNav.classList.add('hidden');

  // render list (notif.js expose window.renderNotificationsList)
  if (window.renderNotificationsList) {
    try { await window.renderNotificationsList(); } catch(e){ console.warn('Erreur affichage notifications', e); }
  } else {
    document.getElementById('placeholderText').textContent = 'Aucune fonctionnalité de notifications trouvée.';
  }
});

    // load external feature scripts (non-blocking if missing)
    const externals = ["./notif.js","./statistics.js","./profiles.js","./tiks.js","./transactions.js","./mingots.js"];
    for (const src of externals) {
      import(src).catch(e => { console.debug('optional module not loaded', src); });
    }

    // --------- Game logic (fallback / core) ---------
    const ROWS = 20, COLS = 20, WIN = 5;
    // sources des pions (mettre les fichiers dans le même dossier que index.html)
const PION_X_SRC = './pion_x.svg';
const PION_O_SRC = './pion_o.svg';
    const board = new Array(ROWS*COLS).fill(null);
    let current = 'X'; // X starts
    let aiMode = true; // IA basique on by default
    let duoLocal = false;

    const boardGrid = document.getElementById('boardGrid');
    const boardViewport = document.getElementById('boardViewport');
    const currentTurn = document.getElementById('currentTurn');
    const scoreX = document.getElementById('scoreX');
    const scoreO = document.getElementById('scoreO');
    const seriesX = document.getElementById('seriesX');
    const seriesO = document.getElementById('seriesO');
    const statGames = document.getElementById('statGames');
    const statWins = document.getElementById('statWins');
    const statTiks = document.getElementById('statTiks');

    let manches = { X:0, O:0 };
    let series = { X:0, O:0 };
    let gamesPlayed = 0, wins = 0;

    function idx(r,c){ return r*COLS + c; }

    // responsive cell size (prevents horizontal overflow)
    function setCellSize(){
      let size = 48;
      const w = window.innerWidth;
      if(w < 420) size = 28;
      else if(w < 640) size = 36;
      else if(w < 1024) size = 40;
      document.documentElement.style.setProperty('--cell-size', size + 'px');
      // set viewport size to show 9x8 cells
      const viewportW = size * 9 + 2; // +2 for borders allowance
      const viewportH = size * 8 + 2;
      boardViewport.style.width = Math.min(viewportW, Math.max(240, viewportW)) + 'px';
      boardViewport.style.height = viewportH + 'px';
      // ensure grid template columns uses var(--cell-size)
      boardGrid.style.gridTemplateColumns = `repeat(${COLS}, var(--cell-size))`;
    }

    window.addEventListener('resize', ()=>{ setCellSize(); renderGrid(); renderMiniMap(); });

    function renderGrid(){
      boardGrid.innerHTML = '';
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const i = idx(r,c);
          const cell = document.createElement('div');
          cell.className = 'board-cell';
          cell.dataset.r = r; cell.dataset.c = c; cell.dataset.i = i;
          cell.addEventListener('click', ()=> onCellClick(r,c));
          const val = board[i];
          if (val) {
  const img = document.createElement('img');
  img.className = 'piece-img';
  img.src = val === 'X' ? PION_X_SRC : PION_O_SRC;
  img.alt = val === 'X' ? 'Pion X' : 'Pion O';
  cell.appendChild(img);
}
          boardGrid.appendChild(cell);
        }
      }
    }

    function inRange(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }

    function countDirection(r,c,dr,dc,symbol){
      let cnt=0; let rr=r+dr, cc=c+dc;
      while(inRange(rr,cc) && board[idx(rr,cc)]===symbol){ cnt++; rr+=dr; cc+=dc; }
      return cnt;
    }

    function checkWinnerAt(r,c){
      const sym = board[idx(r,c)]; if(!sym) return null;
      const dirs = [[1,0],[0,1],[1,1],[1,-1]];
      for(const [dr,dc] of dirs){
        const total = 1 + countDirection(r,c,dr,dc,sym) + countDirection(r,c,-dr,-dc,sym);
        if(total>=WIN) return sym;
      }
      return null;
    }

    function checkAnyWinner(){
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ const w = checkWinnerAt(r,c); if(w) return w; }
      if(board.every(Boolean)) return 'draw';
      return null;
    }

    function onCellClick(r,c){
      if(duoLocal===false && aiMode && current==='O') return; // if AI's turn, ignore clicks
      const i = idx(r,c);
      if(board[i]) return;
      board[i]=current;
      renderGrid();
      const w = checkWinnerAt(r,c) || checkAnyWinner();
      if(w){ handleWin(w); return; }
      current = current === 'X' ? 'O' : 'X';
      currentTurn.textContent = current;
      if(aiMode && current==='O') setTimeout(aiPlay, 200);
    }

    function emptyCells(){ return board.map((v,i)=> v?null:i).filter(Number.isInteger); }

    function aiPlay(){
      const op = 'X', me='O';
      let move = findBestMove(me) ?? findBestMove(op) ?? (emptyCells()[Math.floor(Math.random()*emptyCells().length)]);
      if(move==null) return;
      board[move]=me;
      renderGrid();
      const r = Math.floor(move/COLS), c = move%COLS;
      const w = checkWinnerAt(r,c) || checkAnyWinner();
      if(w){ handleWin(w); return; }
      current = 'X'; currentTurn.textContent = current;
    }

    function findBestMove(symbol){
      let best = null; let bestScore = -1;
      for(const i of emptyCells()){
        const r = Math.floor(i/COLS), c = i%COLS;
        board[i] = symbol;
        const score = evaluatePosition(r,c,symbol);
        board[i] = null;
        if(score > bestScore){ bestScore = score; best = i; }
        if(score >= WIN) { return i; }
      }
      return best;
    }

    function evaluatePosition(r,c,symbol){
      const dirs = [[1,0],[0,1],[1,1],[1,-1]];
      let maxlen = 0;
      for(const [dr,dc] of dirs){
        const len = 1 + countDirection(r,c,dr,dc,symbol) + countDirection(r,c,-dr,-dc,symbol);
        if(len>maxlen) maxlen=len;
      }
      return maxlen;
    }

    function handleWin(winner){
      if(winner==='draw'){
        alert('Match nul.');
      } else {
        alert(`Le gagnant est ${winner}!`);
        manches[winner]++;
        if(manches[winner] >= 3){ series[winner]++; manches.X=0; manches.O=0; }
        scoreX.textContent = manches.X; scoreO.textContent = manches.O; seriesX.textContent = series.X; seriesO.textContent = series.O;
        gamesPlayed++; statGames.textContent = String(gamesPlayed);
        wins++; statWins.textContent = String(wins);
      }
      // the winner starts the next manche (if a player won)
      if(winner === 'X' || winner === 'O') current = winner;
      // reset board for next manche after short delay to let user see
      setTimeout(()=>{ board.fill(null); renderGrid(); currentTurn.textContent = current; }, 300);
    }

    // helpers for reset
    document.getElementById('resetManche').addEventListener('click', ()=>{ manches.X=0; manches.O=0; scoreX.textContent='0'; scoreO.textContent='0'; });
    document.getElementById('resetSerie').addEventListener('click', ()=>{ series.X=0; series.O=0; seriesX.textContent='0'; seriesO.textContent='0'; manches.X=0; manches.O=0; scoreX.textContent='0'; scoreO.textContent='0'; });

    // new game button
    document.getElementById('newGameBtn').addEventListener('click', ()=>{ board.fill(null); renderGrid(); current='X'; currentTurn.textContent='X'; aiMode=true; duoLocal=false; });

    // toggles
    document.getElementById('modeToggle').addEventListener('click', (e)=>{
      aiMode = !aiMode; e.target.textContent = aiMode ? 'Mode: IA basique' : 'Mode: Joueur vs Joueur'; if(!aiMode) duoLocal=false; });
    document.getElementById('duoToggle').addEventListener('click', (e)=>{
      duoLocal = !duoLocal; if(duoLocal) { aiMode=false; document.getElementById('modeToggle').textContent='Mode: Duo Local'; } else { document.getElementById('modeToggle').textContent = aiMode ? 'Mode: IA basique' : 'Mode: Joueur vs Joueur'; }
    });
   
    // minimap rendering and interaction
    function renderMiniMap(){
      const mm = document.getElementById('minimap'); mm.innerHTML='';
      const w = mm.clientWidth; const h = mm.clientHeight;
      const canvas = document.createElement('canvas');
      // high DPI handling
      const ratio = window.devicePixelRatio || 1;
      canvas.width = Math.max(160, w * ratio);
      canvas.height = Math.max(80, h * ratio);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      mm.appendChild(canvas);
      const ctx = canvas.getContext('2d');
      ctx.scale(ratio, ratio);
      ctx.fillStyle='#071022'; ctx.fillRect(0,0,w,h);
      const cellW = w / COLS, cellH = h / ROWS;
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const v = board[idx(r,c)];
          if(!v) continue;
          ctx.fillStyle = v === 'X' ? '#FFD93D' : '#FF6B6B';
          ctx.fillRect(c*cellW, r*cellH, Math.max(1,cellW-1), Math.max(1,cellH-1));
        }
      }
      // draw viewport rectangle
      const vpW = boardViewport.clientWidth, vpH = boardViewport.clientHeight;
      const scrollLeft = boardViewport.scrollLeft, scrollTop = boardViewport.scrollTop;
      // compute visible cell range
      const cellSizePx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
      const firstCol = Math.floor(scrollLeft / cellSizePx);
      const firstRow = Math.floor(scrollTop / cellSizePx);
      const visibleCols = Math.ceil(vpW / cellSizePx);
      const visibleRows = Math.ceil(vpH / cellSizePx);
      ctx.strokeStyle = 'rgba(255,255,255,0.7)'; ctx.lineWidth = 2;
      ctx.strokeRect(firstCol*cellW, firstRow*cellH, visibleCols*cellW, visibleRows*cellH);

      // click to center
      canvas.onclick = (ev) => {
        const rect = canvas.getBoundingClientRect();
        const x = (ev.clientX - rect.left) * (canvas.width / rect.width) / ratio;
        const y = (ev.clientY - rect.top) * (canvas.height / rect.height) / ratio;
        const col = Math.floor(x / cellW);
        const row = Math.floor(y / cellH);
        centerViewportOn(row, col);
      };
    }

    function centerViewportOn(row, col){
      const cell = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
      const vpW = boardViewport.clientWidth, vpH = boardViewport.clientHeight;
      const targetLeft = Math.max(0, Math.round(col * cell - vpW/2 + cell/2));
      const targetTop = Math.max(0, Math.round(row * cell - vpH/2 + cell/2));
      boardViewport.scrollTo({ left: targetLeft, top: targetTop, behavior: 'smooth' });
      setTimeout(renderMiniMap, 250);
    }

    // minimap updates periodically
    setInterval(renderMiniMap, 800);

    // profile upload preview and save logic (basic fallback)
    const avatarFile = document.getElementById('avatarFile'); const avatarPreview = document.getElementById('avatarPreview');
    avatarFile?.addEventListener('change', (e)=>{ const f = e.target.files?.[0]; if(!f) return; avatarPreview.src = URL.createObjectURL(f); });

    document.getElementById('saveProfile').addEventListener('click', ()=>{ document.getElementById('profileMsg').textContent='(Demo) Profil enregistré localement.'; setTimeout(()=>document.getElementById('profileMsg').textContent='', 3000); });
    document.getElementById('cancelProfile').addEventListener('click', ()=>{ profilePanel.classList.add('hidden'); homePanel.classList.remove('hidden'); setActiveMenu(menuHome); });

    // initialize
    setCellSize(); renderGrid(); currentTurn.textContent = current; renderMiniMap();

  </script>
<script>
/*
  Stub lazy-loader : expose un objet window.taktikGame minimal.
  Si create_game.js appelle taktikGame.joinGame(gameId), on importera
  automatiquement ./game.js, on appellera son init et on délèguera l'appel.
*/
window.taktikGame = window.taktikGame || (function () {
  let _loading = null;

  async function _ensureLoaded() {
    if (_loading) return _loading;
    // start loading game.js and initialize it
    _loading = (async () => {
      try {
        const mod = await import('./game.js');
        // game.js doit exporter par défaut initGame(supabase)
        if (mod && typeof mod.default === 'function') {
          // passe window.supabase si présent
          await mod.default(window.supabase ?? null);
        }
        // après init, window.taktikGame devrait avoir été remplacé par l'implémentation complète
      } catch (err) {
        console.warn('Échec du chargement du module game.js :', err);
        throw err;
      }
    })();
    return _loading;
  }

  return {
    // joinGame : si appelé avant que game.js soit chargé, on lazy-load et on ré-appelle
    async joinGame(gameId) {
      try {
        await _ensureLoaded();
        // si game.js a exposé la vraie impl, l'appelera maintenant
        if (window.taktikGame && typeof window.taktikGame.joinGame === 'function' && window.taktikGame._isReal) {
          return window.taktikGame.joinGame(gameId);
        } else {
          console.warn('Module game.js chargé mais joinGame non trouvé.');
        }
      } catch (e) {
        alert('Impossible de charger le jeu complet. Veuillez réessayer.');
        console.error(e);
      }
    },

    // createGame wrapper — idem lazy-load puis délégation
    async createGame(...args) {
      await _ensureLoaded();
      if (window.taktikGame && typeof window.taktikGame.createGame === 'function' && window.taktikGame._isReal) {
        return window.taktikGame.createGame(...args);
      }
      console.warn('createGame non disponible après chargement du jeu.');
    },

    // méthodes utilitaires "stubs" (sécurisent les appels depuis create_game.js)
    resetLocalGame() { console.warn('resetLocalGame stub — jeu complet non chargé.'); },
    placeMove() { console.warn('placeMove stub — jeu complet non chargé.'); },

    // marqueur : stub
    _isReal: false
  };
})();
</script>

  <!-- Optional feature scripts (imported if present) -->
  <script type="module">
    try { await import('./statistics.js'); } catch(e){}
    try { await import('./profiles.js'); } catch(e){}
    try { await import('./tiks.js'); } catch(e){}
    try { await import('./game.js'); } catch(e){}
    try { await import('./transactions.js'); } catch(e){}
    try { await import('./mingots.js'); } catch(e){}
  </script>
<script type="module" src="./auth.js"></script>
<!-- ===== Footer : coller juste avant </body> ===== -->
<footer class="mt-8">
  <div class="max-w-5xl mx-auto px-4 py-4 flex items-center justify-between text-sm text-slate-500">
    <div>©Taktik - <span id="currentYear"></span></div>
    <div>
      <!-- par défaut caché ; le script l'affichera si aucune session -->
      <button id="loginFooterBtn" class="hidden px-3 py-2 rounded-md bg-sky-500 text-white text-sm" aria-label="Se connecter">Se connecter</button>
    </div>
  </div>
</footer>

<script>
(async function(){
  // affiche l'année courante
  document.getElementById('currentYear').textContent = new Date().getFullYear();

    const btn = document.getElementById('loginFooterBtn');
  function onLoginClick(ev){
  // empêche le comportement par défaut si l'appel provient d'un événement
  if (ev && typeof ev.preventDefault === 'function') ev.preventDefault();

  // 1) Si auth.js expose volontairement une fonction globale pour ouvrir la modale, l'utiliser
  if (typeof window.openAuthModal === 'function') {
    try {
      window.openAuthModal();
      return;
    } catch (err) {
      console.warn('openAuthModal() a échoué :', err);
    }
  }

  // 2) Emettre un événement custom que auth.js pourra écouter si tu veux l'ajouter (non intrusif)
  try {
    document.dispatchEvent(new CustomEvent('taktik:open-auth-modal'));
  } catch (err) {
    console.warn('Échec dispatch custom event:', err);
  }

  // 3) Fallback volontairement silencieux : ne pas rediriger vers login.html.
  //    auth.js, importé avant ce script, attache déjà un listener sur #loginFooterBtn
  //    qui ouvre la modale — donc on n'a rien d'autre à faire ici.
  return;
}
  function showLogin(){
    btn.classList.remove('hidden');
    // remove avant d'ajouter pour éviter doublons d'écouteurs
    btn.removeEventListener('click', onLoginClick);
    btn.addEventListener('click', onLoginClick);
  }
  function hideLogin(){
    btn.classList.add('hidden');
    btn.removeEventListener('click', onLoginClick);
  }

  try{
    // récupère supabase si disponible (vérifie window.supabase puis supabase global)
    const sup = (typeof window !== 'undefined' && window.supabase) ? window.supabase : (typeof supabase !== 'undefined' ? supabase : null);

    if(!sup || !sup.auth || typeof sup.auth.getSession !== 'function'){
      // pas de supabase chargé → afficher le bouton (comportement par défaut)
      showLogin();
      return;
    }

    // Vérification initiale de la session
    const res = await sup.auth.getSession();
    const session = res?.data?.session ?? null;
    if (!session || !session.user) {
      showLogin();
    } else {
      hideLogin();
    }

    // Écouteur pour réagir aux changements d'auth (login/logout dans un autre onglet)
    sup.auth.onAuthStateChange((event, sess) => {
      const u = sess?.user ?? null;
      if (u) hideLogin(); else showLogin();
    });

  } catch (err) {
    console.warn('Vérification session footer a échoué', err);
    showLogin();
  }

})();
</script>
<script type="module" src="online.js"></script>.
</body>
</html>
